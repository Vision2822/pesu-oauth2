FULL PROJECT SOURCE DUMP
Base directory: D:\OAuth2\src
================================================================================

FILE: ../package.json
================================================================================
{
  "name": "pesu-oauth2",
  "version": "2.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "db:generate": "drizzle-kit generate",
    "db:migrate": "drizzle-kit migrate",
    "db:push": "drizzle-kit push",
    "db:studio": "drizzle-kit studio"
  },
  "dependencies": {
    "next": "^15.1.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "@neondatabase/serverless": "^0.10.4",
    "drizzle-orm": "^0.38.3",
    "@upstash/redis": "^1.34.3",
    "@upstash/ratelimit": "^2.0.5",
    "iron-session": "^8.0.4",
    "bcryptjs": "^2.4.3",
    "nanoid": "^5.0.9"
  },
  "devDependencies": {
    "@types/node": "^22.10.0",
    "@types/react": "^19.0.0",
    "@types/react-dom": "^19.0.0",
    "@types/bcryptjs": "^2.4.6",
    "typescript": "^5.7.0",
    "drizzle-kit": "^0.30.1",
    "eslint": "^9.0.0",
    "eslint-config-next": "^15.1.0"
  }
}
================================================================================

FILE: ../tsconfig.json
================================================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [{ "name": "next" }],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
================================================================================

FILE: ../next.config.ts
================================================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  serverExternalPackages: ["@neondatabase/serverless"],
};

export default nextConfig;
================================================================================

FILE: ../drizzle.config.ts
================================================================================
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./src/lib/db/schema.ts",
  out: "./drizzle",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
================================================================================

FILE: ../.env.example
================================================================================
DATABASE_URL=postgresql://user:pass@ep-xxx.us-east-2.aws.neon.tech/neondb?sslmode=require

UPSTASH_REDIS_REST_URL=https://xxx.upstash.io
UPSTASH_REDIS_REST_TOKEN=AXxxxxxxxxxxxxxxxxxxxx

SESSION_SECRET=generate-a-64-char-random-string-here

ADMIN_USERS=PES1202504001,PES1202504002

NEXT_PUBLIC_APP_URL=http://localhost:3000

TESTER_CLIENT_ID=
================================================================================

FILE: app/globals.css
================================================================================
:root {
  --g0: #000000;
  --g1: #0a0a0a;
  --g2: #111111;
  --g3: #1a1a1a;
  --g4: #222222;
  --g5: #2a2a2a;
  --g6: #333333;
  --g7: #3a3a3a;
  --g8: #444444;
  --g9: #555555;
  --g10: #666666;
  --g11: #777777;
  --g12: #888888;
  --g13: #999999;
  --g14: #aaaaaa;
  --g15: #bbbbbb;
  --g16: #cccccc;
  --g17: #dddddd;
  --g18: #e0e0e0;
  --g19: #e8e8e8;
  --g20: #f0f0f0;
  --g21: #f5f5f5;
  --g22: #fafafa;
  --g23: #ffffff;

  --bg: var(--g1);
  --fg: var(--g20);
  --muted: var(--g11);
  --border: var(--g5);
  --card: var(--g2);
  --input: var(--g3);
  --hover: var(--g4);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: var(--bg);
  color: var(--fg);
  font-family: "Inter", system-ui, sans-serif;
  font-size: 15px;
  line-height: 1.5;
}

a {
  color: var(--g16);
  text-decoration: none;
}

a:hover {
  color: var(--g23);
}

h1, h2, h3, h4, h5, h6 {
  font-weight: 600;
  letter-spacing: -0.02em;
}

.container {
  max-width: 960px;
  margin: 0 auto;
  padding: 0 1.5rem;
}

.btn {
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  padding: 0.5rem 1rem;
  font-size: 0.85rem;
  font-weight: 500;
  border: 1px solid var(--border);
  border-radius: 0;
  cursor: pointer;
  transition: background 0.15s, border-color 0.15s;
  font-family: inherit;
}

.btn-primary {
  background: var(--g20);
  color: var(--g0);
  border-color: var(--g20);
}

.btn-primary:hover {
  background: var(--g23);
}

.btn-secondary {
  background: transparent;
  color: var(--g16);
  border-color: var(--g6);
}

.btn-secondary:hover {
  background: var(--g3);
  border-color: var(--g10);
}

.btn-danger {
  background: transparent;
  color: #c44;
  border-color: #c44;
}

.btn-danger:hover {
  background: rgba(204, 68, 68, 0.1);
}

.btn-sm {
  padding: 0.3rem 0.6rem;
  font-size: 0.8rem;
}

.card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 0;
  padding: 1.25rem;
}

.form-group {
  margin-bottom: 1rem;
}

.form-label {
  display: block;
  margin-bottom: 0.3rem;
  font-size: 0.8rem;
  color: var(--g13);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.form-input {
  width: 100%;
  padding: 0.5rem 0.7rem;
  background: var(--input);
  border: 1px solid var(--border);
  border-radius: 0;
  color: var(--fg);
  font-size: 0.9rem;
  font-family: inherit;
}

.form-input:focus {
  outline: none;
  border-color: var(--g10);
}

.form-input::placeholder {
  color: var(--g8);
}

.form-hint {
  font-size: 0.75rem;
  color: var(--g10);
  margin-top: 0.25rem;
}

.alert {
  padding: 0.75rem 1rem;
  border-left: 3px solid;
  margin-bottom: 1rem;
  font-size: 0.85rem;
}

.alert-danger {
  background: var(--g2);
  border-color: #c44;
  color: #e88;
}

.alert-success {
  background: var(--g2);
  border-color: #4a4;
  color: #8c8;
}

.alert-warning {
  background: var(--g2);
  border-color: #a80;
  color: #db6;
}

.alert-info {
  background: var(--g2);
  border-color: var(--g10);
  color: var(--g16);
}

.text-muted {
  color: var(--muted);
}

.badge {
  display: inline-block;
  padding: 0.15rem 0.5rem;
  font-size: 0.7rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  border: 1px solid;
}

.badge-info {
  border-color: var(--g10);
  color: var(--g14);
}

.badge-success {
  border-color: #4a4;
  color: #6c6;
}

.badge-warning {
  border-color: #a80;
  color: #db6;
}

code {
  background: var(--g3);
  color: var(--g16);
  padding: 0.1em 0.35em;
  font-size: 0.85em;
}

pre {
  background: var(--g2);
  border: 1px solid var(--border);
  padding: 1rem;
  overflow-x: auto;
  font-size: 0.8rem;
}

pre code {
  background: none;
  padding: 0;
}

.mono {
  font-family: "Courier New", monospace;
}

.divider {
  border: none;
  border-top: 1px solid var(--border);
  margin: 2rem 0;
}

.grid-2 {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1rem;
}

.grid-3 {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 1rem;
}

@media (max-width: 768px) {
  .grid-2, .grid-3 {
    grid-template-columns: 1fr;
  }
}

.checkbox-group {
  display: flex;
  align-items: flex-start;
  gap: 0.5rem;
  padding: 0.4rem 0;
}

.checkbox-group input[type="checkbox"] {
  accent-color: var(--g14);
  margin-top: 0.2rem;
}

table {
  width: 100%;
  border-collapse: collapse;
}

th, td {
  text-align: left;
  padding: 0.5rem 0.75rem;
  border-bottom: 1px solid var(--border);
  font-size: 0.85rem;
}

th {
  color: var(--g13);
  font-weight: 600;
  text-transform: uppercase;
  font-size: 0.7rem;
  letter-spacing: 0.05em;
}
.docs-heading {
  font-size: 1.1rem;
  margin-bottom: 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--border);
  color: var(--g20);
}

.docs-text {
  font-size: 0.85rem;
  color: var(--g14);
  line-height: 1.7;
  margin-bottom: 1rem;
}

.docs-link {
  color: var(--g16);
  text-decoration: underline;
  text-underline-offset: 2px;
}

.docs-link:hover {
  color: var(--g20);
}

.docs-card {
  border: 1px solid var(--border);
  background: var(--g2);
  margin-top: 1rem;
}

.docs-card-header {
  padding: 0.6rem 1rem;
  font-size: 0.75rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--g12);
  background: var(--g3);
  border-bottom: 1px solid var(--border);
}

.docs-card-body {
  padding: 1rem;
}

.docs-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1.5rem;
}

@media (max-width: 600px) {
  .docs-grid {
    grid-template-columns: 1fr;
  }
}

.docs-flow {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin: 1.5rem 0;
  flex-wrap: wrap;
}

.docs-flow-step {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 0.75rem;
  background: var(--g3);
  border: 1px solid var(--border);
  font-size: 0.8rem;
  color: var(--g14);
}

.docs-flow-num {
  width: 1.25rem;
  height: 1.25rem;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--g6);
  color: var(--g16);
  font-size: 0.7rem;
  font-weight: 600;
}

.docs-flow-arrow {
  color: var(--g8);
  font-size: 0.9rem;
}

.docs-table-wrapper {
  overflow-x: auto;
  margin-top: 1rem;
}

.code-block {
  margin: 1.5rem 0;
  border: 1px solid var(--g5);
  background: var(--g2);
  overflow: hidden;
}

.code-tabs {
  display: flex;
  border-bottom: 1px solid var(--g5);
  background: var(--g3);
}

.code-tab {
  padding: 0.6rem 1rem;
  font-size: 0.8rem;
  font-weight: 500;
  background: none;
  border: none;
  border-bottom: 2px solid transparent;
  cursor: pointer;
  transition: all 0.15s ease;
  font-family: inherit;
}

.code-tab:hover {
  background: var(--g4);
}

.code-tab.active {
  background: var(--g2);
}

.code-tab-spacer {
  flex: 1;
}

.code-content {
  position: relative;
}

.code-header {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  padding: 0.6rem 1rem;
  border-bottom: 1px solid var(--g5);
}

.code-dot {
  width: 0.6rem;
  height: 0.6rem;
  border-radius: 50%;
}

.code-lang {
  margin-left: auto;
  font-size: 0.7rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}

.code-pre {
  margin: 0;
  padding: 1rem;
  overflow-x: auto;
  font-size: 0.8rem;
  line-height: 1.6;
  background: transparent;
  border: none;
}

.code-pre code {
  background: none;
  padding: 0;
  font-family: "SF Mono", "Fira Code", "JetBrains Mono", monospace;
  color: var(--g15);
}

.code-keyword {
  color: #c678dd;
  font-weight: 500;
}

.code-string {
  color: #98c379;
}

.code-comment {
  color: #5c6370;
  font-style: italic;
}

.code-function {
  color: #61afef;
}
================================================================================

FILE: app/layout.tsx
================================================================================
import type { Metadata } from "next";
import { Navbar } from "@/components/navbar";
import { Footer } from "@/components/footer";
import "./globals.css";

export const metadata: Metadata = {
  title: "PESU Auth",
  description: "OAuth2 for PESU",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <head>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link
          rel="preconnect"
          href="https://fonts.gstatic.com"
          crossOrigin="anonymous"
        />
        <link
          href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
          rel="stylesheet"
        />
      </head>
      <body>
        <Navbar />
        <main style={{ paddingTop: "3.5rem", minHeight: "80vh" }}>
          {children}
        </main>
        <Footer />
      </body>
    </html>
  );
}
================================================================================

FILE: app/page.tsx
================================================================================
import Link from "next/link";

export default function HomePage() {
  return (
    <div className="container" style={{ paddingTop: "8rem" }}>
      <section style={{ maxWidth: "520px" }}>
        <p className="text-muted" style={{ fontSize: "0.8rem", marginBottom: "0.5rem" }}>
          PESU OAuth2
        </p>
        <h1 style={{ fontSize: "2rem", lineHeight: 1.2, marginBottom: "1rem" }}>
          One login for the PESU ecosystem.
        </h1>
        <p className="text-muted" style={{ fontSize: "0.9rem", marginBottom: "2rem" }}>
          Authenticate students. Share profile data with consent. Built for
          developers building on top of PESU.
        </p>
        <div style={{ display: "flex", gap: "0.5rem" }}>
          <Link href="/docs" className="btn btn-primary">
            Docs
          </Link>
          <Link href="/login" className="btn btn-secondary">
            Sign in
          </Link>
        </div>
      </section>

      <hr className="divider" style={{ margin: "4rem 0" }} />

      <section className="grid-3" style={{ marginBottom: "6rem" }}>
        <div>
          <h4 style={{ fontSize: "0.85rem", marginBottom: "0.4rem" }}>
            No passwords stored
          </h4>
          <p className="text-muted" style={{ fontSize: "0.8rem" }}>
            Credentials are forwarded to PESU Academy and discarded.
          </p>
        </div>
        <div>
          <h4 style={{ fontSize: "0.85rem", marginBottom: "0.4rem" }}>
            Granular consent
          </h4>
          <p className="text-muted" style={{ fontSize: "0.8rem" }}>
            Users pick exactly which fields to share per app.
          </p>
        </div>
        <div>
          <h4 style={{ fontSize: "0.85rem", marginBottom: "0.4rem" }}>
            Open source
          </h4>
          <p className="text-muted" style={{ fontSize: "0.8rem" }}>
            Every line is public. Audit it yourself.
          </p>
        </div>
      </section>
    </div>
  );
}
================================================================================

FILE: app/about/page.tsx
================================================================================
export default function AboutPage() {
  return (
    <div className="container" style={{ paddingTop: "6rem", maxWidth: "600px" }}>
      <h1 style={{ fontSize: "1.5rem", marginBottom: "1.5rem" }}>About</h1>

      <section style={{ marginBottom: "2rem" }}>
        <h2 style={{ fontSize: "1rem", marginBottom: "0.5rem", color: "var(--g16)" }}>
          What is this?
        </h2>
        <p style={{ fontSize: "0.85rem", color: "var(--g13)", lineHeight: 1.6 }}>
          PESU Auth lets you sign into student-made apps using your PESU Academy
          account. Instead of creating a new username and password for every app,
          you just click &quot;Sign in with PESU&quot; and you&apos;re in.
        </p>
      </section>

      <section style={{ marginBottom: "2rem" }}>
        <h2 style={{ fontSize: "1rem", marginBottom: "0.5rem", color: "var(--g16)" }}>
          How does it work?
        </h2>
        <p style={{ fontSize: "0.85rem", color: "var(--g13)", lineHeight: 1.6 }}>
          When you sign in, your credentials go directly to PESU Academy for
          verification. If correct, we get your profile info (name, PRN, branch,
          etc). We then ask what info you want to share with the app. You choose.
          The app only sees what you allow.
        </p>
      </section>

      <section style={{ marginBottom: "2rem" }}>
        <h2 style={{ fontSize: "1rem", marginBottom: "0.5rem", color: "var(--g16)" }}>
          Is my password stored?
        </h2>
        <p style={{ fontSize: "0.85rem", color: "var(--g13)", lineHeight: 1.6 }}>
          No. Your password is sent to PESU Academy to verify you, then discarded.
          We never save it.
        </p>
      </section>

      <section style={{ marginBottom: "2rem" }}>
        <h2 style={{ fontSize: "1rem", marginBottom: "0.5rem", color: "var(--g16)" }}>
          Who made this?
        </h2>
        <p style={{ fontSize: "0.85rem", color: "var(--g13)", lineHeight: 1.6 }}>
          A student project. Not affiliated with PES University. The code is
          open source — you can read every line on GitHub.
        </p>
      </section>

      <div
        style={{
          marginTop: "2rem",
          padding: "1rem",
          background: "var(--g2)",
          border: "1px solid var(--border)",
          fontSize: "0.8rem",
          color: "var(--g12)",
        }}
      >
        Questions? Open an issue on{" "}
        <a
          href="https://github.com/Vision2822/pesu-oauth2/issues"
          target="_blank"
          style={{ color: "var(--g16)", textDecoration: "underline" }}
        >
          GitHub
        </a>
        .
      </div>
    </div>
  );
}
================================================================================

FILE: app/admin/action.ts
================================================================================
"use server";

import { revalidatePath } from "next/cache";
import { db } from "@/lib/db";
import { oauth2Clients } from "@/lib/db/schema";
import { eq, and } from "drizzle-orm";
import { requireAdmin } from "@/lib/auth";
import { nanoid } from "nanoid";
import bcrypt from "bcryptjs";

interface CreateState {
  error: string | null;
  success: string | null;
  clientId: string | null;
  clientSecret: string | null;
}

export async function createClientAction(
  _prev: CreateState,
  formData: FormData
): Promise<CreateState> {
  let user;
  try {
    user = await requireAdmin();
  } catch {
    return { error: "Unauthorized.", success: null, clientId: null, clientSecret: null };
  }

  const clientName = (formData.get("client_name") as string)?.trim();
  const redirectUrisRaw = (formData.get("redirect_uris") as string)?.trim();
  const clientType = formData.get("client_type") as string;
  const scopes = formData.getAll("scope") as string[];

  if (!clientName) {
    return { error: "Client name is required.", success: null, clientId: null, clientSecret: null };
  }

  const redirectUris = redirectUrisRaw
    .split(/\s+/)
    .filter((uri) => {
      try {
        const parsed = new URL(uri);
        return ["http:", "https:"].includes(parsed.protocol);
      } catch {
        return false;
      }
    });

  if (redirectUris.length === 0) {
    return { error: "At least one valid redirect URI required.", success: null, clientId: null, clientSecret: null };
  }

  if (scopes.length === 0) {
    return { error: "At least one scope required.", success: null, clientId: null, clientSecret: null };
  }

  const clientId = nanoid(32);
  const isPublic = clientType !== "confidential";

  if (isPublic) {
    await db.insert(oauth2Clients).values({
      userId: user.id,
      clientId,
      clientSecret: null,
      clientName,
      redirectUris,
      scope: scopes.join(" "),
      tokenEndpointAuthMethod: "none",
    });

    revalidatePath("/admin");
    return {
      error: null,
      success: "Public client created.",
      clientId,
      clientSecret: null,
    };
  } else {
    const plainSecret = nanoid(48);
    const hashed = await bcrypt.hash(plainSecret, 12);

    await db.insert(oauth2Clients).values({
      userId: user.id,
      clientId,
      clientSecret: hashed,
      clientName,
      redirectUris,
      scope: scopes.join(" "),
      tokenEndpointAuthMethod: "client_secret_post",
    });

    revalidatePath("/admin");
    return {
      error: null,
      success: "Confidential client created.",
      clientId,
      clientSecret: plainSecret,
    };
  }
}

export async function deleteClientAction(formData: FormData) {
  let user;
  try {
    user = await requireAdmin();
  } catch {
    return;
  }

  const id = parseInt(formData.get("id") as string, 10);
  if (isNaN(id)) return;

  await db
    .delete(oauth2Clients)
    .where(and(eq(oauth2Clients.id, id), eq(oauth2Clients.userId, user.id)));

  revalidatePath("/admin");
}
================================================================================

FILE: app/admin/create-client-form.tsx
================================================================================
"use client";

import { useActionState } from "react";
import { createClientAction } from "./action";

interface Props {
  availableScopes: Record<string, string>;
}

interface State {
  error: string | null;
  success: string | null;
  clientId: string | null;
  clientSecret: string | null;
}

const initial: State = {
  error: null,
  success: null,
  clientId: null,
  clientSecret: null,
};

export function CreateClientForm({ availableScopes }: Props) {
  const [state, formAction, pending] = useActionState(createClientAction, initial);

  return (
    <div>
      {state.error && (
        <div className="alert alert-danger">{state.error}</div>
      )}

      {state.success && (
        <div className="alert alert-success">
          <strong>{state.success}</strong>
          <br />
          <span style={{ fontSize: "0.8rem" }}>
            Client ID: <code>{state.clientId}</code>
          </span>
          {state.clientSecret && (
            <>
              <br />
              <span style={{ fontSize: "0.8rem" }}>
                Client Secret:{" "}
                <code style={{ wordBreak: "break-all" }}>{state.clientSecret}</code>
              </span>
              <br />
              <span style={{ fontSize: "0.75rem", color: "var(--g12)" }}>
                Copy the secret now — it will not be shown again.
              </span>
            </>
          )}
        </div>
      )}

      <form action={formAction}>
        <div className="form-group">
          <label className="form-label" htmlFor="client_name">
            Client Name
          </label>
          <input
            className="form-input"
            type="text"
            id="client_name"
            name="client_name"
            required
          />
        </div>

        <div className="form-group">
          <label className="form-label" htmlFor="redirect_uris">
            Redirect URIs
          </label>
          <input
            className="form-input"
            type="text"
            id="redirect_uris"
            name="redirect_uris"
            placeholder="https://myapp.com/callback http://localhost:3000/callback"
            required
          />
          <p className="form-hint">Space-separated. Must use http or https.</p>
        </div>

        <div className="form-group">
          <label className="form-label">Client Type</label>
          <div style={{ display: "flex", gap: "1rem", marginTop: "0.25rem" }}>
            <label style={{ display: "flex", alignItems: "center", gap: "0.4rem", fontSize: "0.85rem", cursor: "pointer" }}>
              <input type="radio" name="client_type" value="public" defaultChecked />
              Public
            </label>
            <label style={{ display: "flex", alignItems: "center", gap: "0.4rem", fontSize: "0.85rem", cursor: "pointer" }}>
              <input type="radio" name="client_type" value="confidential" />
              Confidential
            </label>
          </div>
          <p className="form-hint">
            Public = SPA / mobile. Confidential = backend server.
          </p>
        </div>

        <div className="form-group">
          <label className="form-label">Allowed Scopes</label>
          <div
            style={{
              border: "1px solid var(--border)",
              background: "var(--g2)",
              padding: "0.75rem",
            }}
          >
            {Object.entries(availableScopes).map(([scope, desc]) => (
              <div className="checkbox-group" key={scope}>
                <input
                  type="checkbox"
                  name="scope"
                  value={scope}
                  id={`scope-${scope}`}
                  defaultChecked
                />
                <label htmlFor={`scope-${scope}`} style={{ fontSize: "0.8rem" }}>
                  <code>{scope}</code>
                  <span className="text-muted"> — {desc}</span>
                </label>
              </div>
            ))}
          </div>
        </div>

        <button
          type="submit"
          className="btn btn-primary"
          disabled={pending}
        >
          {pending ? "Creating..." : "Create Client"}
        </button>
      </form>
    </div>
  );
}
================================================================================

FILE: app/admin/page.tsx
================================================================================
import { redirect } from "next/navigation";
import { requireAdmin } from "@/lib/auth";
import { db } from "@/lib/db";
import { oauth2Clients } from "@/lib/db/schema";
import { eq } from "drizzle-orm";
import { AVAILABLE_SCOPES } from "@/lib/constants";
import { ClientCard } from "@/components/client-card";
import { CreateClientForm } from "./create-client-form";

export default async function AdminPage() {
  let user;
  try {
    user = await requireAdmin();
  } catch {
    redirect("/login?next=/admin");
  }

  const clients = await db
    .select()
    .from(oauth2Clients)
    .where(eq(oauth2Clients.userId, user.id));

  return (
    <div className="container" style={{ paddingTop: "6rem", maxWidth: "720px" }}>
      <h1 style={{ fontSize: "1.3rem", marginBottom: "0.25rem" }}>
        Client Management
      </h1>
      <p className="text-muted" style={{ fontSize: "0.8rem", marginBottom: "2rem" }}>
        Registered OAuth2 clients for your account.
      </p>

      <section style={{ marginBottom: "3rem" }}>
        <h2
          style={{
            fontSize: "0.75rem",
            textTransform: "uppercase",
            letterSpacing: "0.05em",
            color: "var(--g12)",
            marginBottom: "1rem",
            paddingBottom: "0.5rem",
            borderBottom: "1px solid var(--border)",
          }}
        >
          Create New Client
        </h2>
        <CreateClientForm availableScopes={AVAILABLE_SCOPES} />
      </section>

      <section>
        <h2
          style={{
            fontSize: "0.75rem",
            textTransform: "uppercase",
            letterSpacing: "0.05em",
            color: "var(--g12)",
            marginBottom: "1rem",
            paddingBottom: "0.5rem",
            borderBottom: "1px solid var(--border)",
          }}
        >
          Existing Clients ({clients.length})
        </h2>

        {clients.length === 0 ? (
          <p className="text-muted" style={{ fontSize: "0.8rem" }}>
            No clients yet.
          </p>
        ) : (
          <div style={{ display: "flex", flexDirection: "column", gap: "0.75rem" }}>
            {clients.map((client) => (
              <ClientCard key={client.id} client={client} />
            ))}
          </div>
        )}
      </section>
    </div>
  );
}
================================================================================

FILE: app/api/health/route.ts
================================================================================
import { db } from "@/lib/db";
import { sql } from "drizzle-orm";
import { NextResponse } from "next/server";

export async function GET() {
  try {
    await db.execute(sql`SELECT 1`);
    return NextResponse.json({
      status: "healthy",
      timestamp: new Date().toISOString(),
    });
  } catch (e) {
    return NextResponse.json(
      {
        status: "unhealthy",
        error: e instanceof Error ? e.message : "Unknown error",
      },
      { status: 503 }
    );
  }
}
================================================================================

FILE: app/api/oauth2/token/route.ts
================================================================================
import { NextRequest, NextResponse } from "next/server";
import { handleTokenRequest } from "@/lib/oauth2/grants";
import { tokenLimit } from "@/lib/rate-limit";

export async function POST(request: NextRequest) {
  const ip =
    request.headers.get("x-forwarded-for")?.split(",")[0]?.trim() ?? "unknown";
  const { success } = await tokenLimit.limit(ip);
  if (!success) {
    return NextResponse.json(
      { error: "rate_limit", error_description: "Too many requests" },
      { status: 429 }
    );
  }

  const contentType = request.headers.get("content-type") ?? "";
  let params: Record<string, string> = {};

  if (contentType.includes("application/x-www-form-urlencoded")) {
    const body = await request.text();
    const parsed = new URLSearchParams(body);
    parsed.forEach((value, key) => {
      params[key] = value;
    });
  } else if (contentType.includes("application/json")) {
    params = await request.json();
  } else {
    return NextResponse.json(
      { error: "invalid_request", error_description: "Unsupported content type" },
      { status: 400 }
    );
  }

  const result = await handleTokenRequest({
    grant_type: params.grant_type ?? "",
    code: params.code,
    redirect_uri: params.redirect_uri,
    client_id: params.client_id ?? "",
    client_secret: params.client_secret,
    code_verifier: params.code_verifier,
    refresh_token: params.refresh_token,
  });

  return NextResponse.json(result.data, { status: result.status });
}
================================================================================

FILE: app/api/v1/user/route.ts
================================================================================
import { NextRequest, NextResponse } from "next/server";
import { validateAccessToken } from "@/lib/oauth2/tokens";
import { db } from "@/lib/db";
import { users } from "@/lib/db/schema";
import { eq } from "drizzle-orm";
import { apiLimit } from "@/lib/rate-limit";

export async function GET(request: NextRequest) {
  const ip =
    request.headers.get("x-forwarded-for")?.split(",")[0]?.trim() ?? "unknown";
  const { success } = await apiLimit.limit(ip);
  if (!success) {
    return NextResponse.json(
      { error: "rate_limit", message: "Too many requests" },
      { status: 429 }
    );
  }

  const auth = request.headers.get("authorization");
  if (!auth || !auth.startsWith("Bearer ")) {
    return NextResponse.json(
      { error: "invalid_token", message: "Missing or malformed Authorization header" },
      { status: 401 }
    );
  }

  const tokenString = auth.slice(7);
  const token = await validateAccessToken(tokenString);

  if (!token) {
    return NextResponse.json(
      { error: "invalid_token", message: "Token is invalid or expired" },
      { status: 401 }
    );
  }

  const userResult = await db
    .select()
    .from(users)
    .where(eq(users.id, token.userId))
    .limit(1);

  if (userResult.length === 0) {
    return NextResponse.json(
      { error: "invalid_token", message: "User not found" },
      { status: 401 }
    );
  }

  const profile = (userResult[0].profileData ?? {}) as Record<string, unknown>;
  const tokenScopes = (token.scope ?? "").split(" ");
  const grantedFields = (token.grantedFields ?? {}) as Record<string, string[]>;
  const response: Record<string, unknown> = {};

  for (const scope of tokenScopes) {
    const fields = grantedFields[scope];
    if (!fields) continue;
    for (const field of fields) {
      if (field in profile) {
        response[field] = profile[field];
      }
    }
  }

  if (Object.keys(response).length === 0) {
    return NextResponse.json(
      { error: "insufficient_scope", message: "No data available with granted permissions" },
      { status: 403 }
    );
  }

  return NextResponse.json(response);
}
================================================================================

FILE: app/docs/code-tabs.tsx
================================================================================
"use client";

import { useState } from "react";

interface Tab {
  lang: string;
  code: string;
}

interface Props {
  tabs: Tab[];
}

const LANG_COLORS: Record<string, { bg: string; text: string; accent: string }> = {
  JavaScript: { bg: "#1a1a1a", text: "#f7df1e", accent: "#f7df1e" },
  Python: { bg: "#1a1a1a", text: "#3776ab", accent: "#ffd43b" },
  Go: { bg: "#1a1a1a", text: "#00add8", accent: "#00add8" },
};

const SYNTAX: Record<string, { keywords: string[]; strings: RegExp; comments: RegExp; functions: RegExp }> = {
  JavaScript: {
    keywords: ["const", "let", "var", "async", "await", "function", "return", "new", "import", "from", "export", "if", "else", "for", "while"],
    strings: /(["'`])(?:(?!\1)[^\\]|\\.)*\1/g,
    comments: /(\/\/.*$|\/\*[\s\S]*?\*\/)/gm,
    functions: /\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g,
  },
  Python: {
    keywords: ["import", "from", "def", "return", "if", "else", "for", "while", "in", "as", "with", "class", "async", "await", "None", "True", "False"],
    strings: /(["'])(?:(?!\1)[^\\]|\\.)*\1|f(["'])(?:(?!\2)[^\\]|\\.)*\2/g,
    comments: /(#.*$)/gm,
    functions: /\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g,
  },
  Go: {
    keywords: ["package", "import", "func", "return", "if", "else", "for", "range", "var", "const", "type", "struct", "interface", "map", "make", "nil"],
    strings: /(["'`])(?:(?!\1)[^\\]|\\.)*\1/g,
    comments: /(\/\/.*$|\/\*[\s\S]*?\*\/)/gm,
    functions: /\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g,
  },
};

function highlightCode(code: string, lang: string): string {
  const syntax = SYNTAX[lang];
  if (!syntax) return escapeHtml(code);

  let highlighted = escapeHtml(code);

  highlighted = highlighted.replace(
    syntax.comments,
    '<span class="code-comment">$1</span>'
  );

  highlighted = highlighted.replace(
    syntax.strings,
    '<span class="code-string">$&</span>'
  );

  syntax.keywords.forEach((kw) => {
    const regex = new RegExp(`\\b(${kw})\\b`, "g");
    highlighted = highlighted.replace(regex, '<span class="code-keyword">$1</span>');
  });

  highlighted = highlighted.replace(
    /\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g,
    '<span class="code-function">$1</span>('
  );

  return highlighted;
}

function escapeHtml(str: string): string {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

export function CodeTabs({ tabs }: Props) {
  const [active, setActive] = useState(0);
  const currentTab = tabs[active];
  const colors = LANG_COLORS[currentTab.lang] || LANG_COLORS.JavaScript;

  return (
    <div className="code-block">
      <div className="code-tabs">
        {tabs.map((tab, i) => {
          const c = LANG_COLORS[tab.lang] || LANG_COLORS.JavaScript;
          return (
            <button
              key={tab.lang}
              onClick={() => setActive(i)}
              className={`code-tab ${i === active ? "active" : ""}`}
              style={{
                borderBottomColor: i === active ? c.accent : "transparent",
                color: i === active ? c.text : "var(--g10)",
              }}
            >
              {tab.lang}
            </button>
          );
        })}
        <div className="code-tab-spacer" />
      </div>
      <div className="code-content" style={{ background: colors.bg }}>
        <div className="code-header">
          <span className="code-dot" style={{ background: "#ff5f56" }} />
          <span className="code-dot" style={{ background: "#ffbd2e" }} />
          <span className="code-dot" style={{ background: "#27ca40" }} />
          <span className="code-lang" style={{ color: colors.accent }}>
            {currentTab.lang.toLowerCase()}
          </span>
        </div>
        <pre className="code-pre">
          <code
            dangerouslySetInnerHTML={{
              __html: highlightCode(currentTab.code, currentTab.lang),
            }}
          />
        </pre>
      </div>
    </div>
  );
}
================================================================================

FILE: app/docs/page.tsx
================================================================================
import { AVAILABLE_SCOPES } from "@/lib/constants";
import { CodeTabs } from "./code-tabs";

export default function DocsPage() {
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL ?? "https://your-domain.com";

  return (
    <div className="container" style={{ paddingTop: "6rem", maxWidth: "780px" }}>
      <h1 style={{ fontSize: "1.5rem", marginBottom: "0.5rem" }}>Documentation</h1>
      <p className="text-muted" style={{ fontSize: "0.85rem", marginBottom: "2.5rem" }}>
        Integrate PESU Auth into your app.
      </p>

      <section style={{ marginBottom: "3rem" }}>
        <h2 className="docs-heading">Overview</h2>
        <p className="docs-text">
          PESU Auth implements OAuth 2.0 Authorization Code flow with PKCE. Your app
          redirects users here to authenticate, receives an authorization code,
          exchanges it for tokens, then fetches user data.
        </p>
        <div className="docs-flow">
          <div className="docs-flow-step">
            <span className="docs-flow-num">1</span>
            <span>Create Client</span>
          </div>
          <div className="docs-flow-arrow">→</div>
          <div className="docs-flow-step">
            <span className="docs-flow-num">2</span>
            <span>Generate PKCE</span>
          </div>
          <div className="docs-flow-arrow">→</div>
          <div className="docs-flow-step">
            <span className="docs-flow-num">3</span>
            <span>Redirect User</span>
          </div>
          <div className="docs-flow-arrow">→</div>
          <div className="docs-flow-step">
            <span className="docs-flow-num">4</span>
            <span>Exchange Code</span>
          </div>
          <div className="docs-flow-arrow">→</div>
          <div className="docs-flow-step">
            <span className="docs-flow-num">5</span>
            <span>Fetch User</span>
          </div>
        </div>
      </section>

      <section style={{ marginBottom: "3rem" }}>
        <h2 className="docs-heading">1. Create a Client</h2>
        <p className="docs-text">
          Go to <a href="/admin" className="docs-link">/admin</a> and
          create an OAuth client. You&apos;ll receive a <code>client_id</code>.
          For public clients (SPAs, mobile apps), no secret is needed — PKCE handles security.
        </p>
        <div className="docs-card">
          <div className="docs-card-header">Client Types</div>
          <div className="docs-card-body">
            <div className="docs-grid">
              <div>
                <strong style={{ color: "var(--g18)" }}>Public</strong>
                <p style={{ fontSize: "0.8rem", color: "var(--g11)", marginTop: "0.25rem" }}>
                  SPAs, mobile apps, CLIs. No secret, PKCE required.
                </p>
              </div>
              <div>
                <strong style={{ color: "var(--g18)" }}>Confidential</strong>
                <p style={{ fontSize: "0.8rem", color: "var(--g11)", marginTop: "0.25rem" }}>
                  Backend servers. Has secret + PKCE for extra security.
                </p>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section style={{ marginBottom: "3rem" }}>
        <h2 className="docs-heading">2. Generate PKCE</h2>
        <p className="docs-text">
          PKCE prevents authorization code interception attacks. Generate a random
          <code>code_verifier</code>, then create a <code>code_challenge</code> by
          SHA-256 hashing it.
        </p>
        <CodeTabs
          tabs={[
            {
              lang: "JavaScript",
              code: `// Generate code_verifier (random string)
const codeVerifier = crypto.randomUUID() + crypto.randomUUID();

// Generate code_challenge (SHA-256 hash, base64url encoded)
async function generateChallenge(verifier) {
  const encoder = new TextEncoder();
  const data = encoder.encode(verifier);
  const hash = await crypto.subtle.digest('SHA-256', data);
  
  return btoa(String.fromCharCode(...new Uint8Array(hash)))
    .replace(/\\+/g, '-')
    .replace(/\\//g, '_')
    .replace(/=+$/, '');
}

const codeChallenge = await generateChallenge(codeVerifier);

// Store verifier for later (you'll need it for token exchange)
sessionStorage.setItem('code_verifier', codeVerifier);`,
            },
            {
              lang: "Python",
              code: `import hashlib
import base64
import secrets

# Generate code_verifier (random string)
code_verifier = secrets.token_urlsafe(64)

# Generate code_challenge (SHA-256 hash, base64url encoded)
digest = hashlib.sha256(code_verifier.encode()).digest()
code_challenge = base64.urlsafe_b64encode(digest).rstrip(b'=').decode()

# Store verifier in session for later
session['code_verifier'] = code_verifier`,
            },
            {
              lang: "Go",
              code: `import (
    "crypto/rand"
    "crypto/sha256"
    "encoding/base64"
)

// Generate code_verifier (random string)
verifierBytes := make([]byte, 64)
rand.Read(verifierBytes)
codeVerifier := base64.RawURLEncoding.EncodeToString(verifierBytes)

// Generate code_challenge (SHA-256 hash, base64url encoded)
hash := sha256.Sum256([]byte(codeVerifier))
codeChallenge := base64.RawURLEncoding.EncodeToString(hash[:])

// Store verifier for later use`,
            },
          ]}
        />
      </section>

      <section style={{ marginBottom: "3rem" }}>
        <h2 className="docs-heading">3. Redirect to Authorize</h2>
        <p className="docs-text">
          Send users to the authorization endpoint with your client details and PKCE challenge.
        </p>
        <CodeTabs
          tabs={[
            {
              lang: "JavaScript",
              code: `const authUrl = new URL('${baseUrl}/oauth2/authorize');

authUrl.searchParams.set('response_type', 'code');
authUrl.searchParams.set('client_id', 'YOUR_CLIENT_ID');
authUrl.searchParams.set('redirect_uri', 'https://yourapp.com/callback');
authUrl.searchParams.set('scope', 'profile:basic profile:contact');
authUrl.searchParams.set('state', crypto.randomUUID()); // CSRF protection
authUrl.searchParams.set('code_challenge', codeChallenge);
authUrl.searchParams.set('code_challenge_method', 'S256');

// Redirect user
window.location.href = authUrl.toString();`,
            },
            {
              lang: "Python",
              code: `from urllib.parse import urlencode
import secrets

params = {
    'response_type': 'code',
    'client_id': 'YOUR_CLIENT_ID',
    'redirect_uri': 'https://yourapp.com/callback',
    'scope': 'profile:basic profile:contact',
    'state': secrets.token_urlsafe(32),  # CSRF protection
    'code_challenge': code_challenge,
    'code_challenge_method': 'S256',
}

auth_url = f'${baseUrl}/oauth2/authorize?{urlencode(params)}'

# Redirect user (Flask example)
return redirect(auth_url)`,
            },
            {
              lang: "Go",
              code: `import "net/url"

authURL, _ := url.Parse("${baseUrl}/oauth2/authorize")

q := authURL.Query()
q.Set("response_type", "code")
q.Set("client_id", "YOUR_CLIENT_ID")
q.Set("redirect_uri", "https://yourapp.com/callback")
q.Set("scope", "profile:basic profile:contact")
q.Set("state", generateRandomState()) // CSRF protection
q.Set("code_challenge", codeChallenge)
q.Set("code_challenge_method", "S256")

authURL.RawQuery = q.Encode()

// Redirect user
http.Redirect(w, r, authURL.String(), http.StatusFound)`,
            },
          ]}
        />
      </section>

      <section style={{ marginBottom: "3rem" }}>
        <h2 className="docs-heading">4. Exchange Code for Token</h2>
        <p className="docs-text">
          After user authorizes, they&apos;re redirected back with a <code>code</code>.
          Exchange it for tokens using your stored <code>code_verifier</code>.
        </p>
        <CodeTabs
          tabs={[
            {
              lang: "JavaScript",
              code: `// Get code from URL params
const code = new URLSearchParams(window.location.search).get('code');
const codeVerifier = sessionStorage.getItem('code_verifier');

const response = await fetch('${baseUrl}/api/oauth2/token', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded',
  },
  body: new URLSearchParams({
    grant_type: 'authorization_code',
    code: code,
    redirect_uri: 'https://yourapp.com/callback',
    client_id: 'YOUR_CLIENT_ID',
    code_verifier: codeVerifier,
  }),
});

const tokens = await response.json();
// {
//   access_token: "...",
//   token_type: "Bearer",
//   expires_in: 3600,
//   refresh_token: "...",
//   scope: "profile:basic profile:contact"
// }`,
            },
            {
              lang: "Python",
              code: `import requests

code = request.args.get('code')
code_verifier = session.get('code_verifier')

response = requests.post(
    '${baseUrl}/api/oauth2/token',
    data={
        'grant_type': 'authorization_code',
        'code': code,
        'redirect_uri': 'https://yourapp.com/callback',
        'client_id': 'YOUR_CLIENT_ID',
        'code_verifier': code_verifier,
    }
)

tokens = response.json()
access_token = tokens['access_token']
refresh_token = tokens['refresh_token']`,
            },
            {
              lang: "Go",
              code: `import (
    "net/http"
    "net/url"
    "encoding/json"
)

code := r.URL.Query().Get("code")
codeVerifier := getFromSession("code_verifier")

resp, _ := http.PostForm("${baseUrl}/api/oauth2/token",
    url.Values{
        "grant_type":    {"authorization_code"},
        "code":          {code},
        "redirect_uri":  {"https://yourapp.com/callback"},
        "client_id":     {"YOUR_CLIENT_ID"},
        "code_verifier": {codeVerifier},
    },
)

var tokens struct {
    AccessToken  string \`json:"access_token"\`
    RefreshToken string \`json:"refresh_token"\`
    ExpiresIn    int    \`json:"expires_in"\`
}
json.NewDecoder(resp.Body).Decode(&tokens)`,
            },
          ]}
        />
      </section>

      <section style={{ marginBottom: "3rem" }}>
        <h2 className="docs-heading">5. Fetch User Info</h2>
        <p className="docs-text">
          Use the access token to retrieve user data. Only fields the user consented to will be returned.
        </p>
        <CodeTabs
          tabs={[
            {
              lang: "JavaScript",
              code: `const response = await fetch('${baseUrl}/api/v1/user', {
  headers: {
    'Authorization': \`Bearer \${accessToken}\`,
  },
});

const user = await response.json();
// {
//   name: "John Doe",
//   prn: "PES1202504001",
//   srn: "PES1UG25CS001",
//   email: "john@example.com",
//   phone: "9876543210"
// }

console.log(\`Welcome, \${user.name}!\`);`,
            },
            {
              lang: "Python",
              code: `response = requests.get(
    '${baseUrl}/api/v1/user',
    headers={
        'Authorization': f'Bearer {access_token}',
    }
)

user = response.json()
# {
#   "name": "John Doe",
#   "prn": "PES1202504001",
#   "srn": "PES1UG25CS001",
#   "email": "john@example.com",
#   "phone": "9876543210"
# }

print(f"Welcome, {user['name']}!")`,
            },
            {
              lang: "Go",
              code: `req, _ := http.NewRequest("GET", "${baseUrl}/api/v1/user", nil)
req.Header.Set("Authorization", "Bearer "+accessToken)

client := &http.Client{}
resp, _ := client.Do(req)

var user struct {
    Name  string \`json:"name"\`
    PRN   string \`json:"prn"\`
    SRN   string \`json:"srn"\`
    Email string \`json:"email"\`
    Phone string \`json:"phone"\`
}
json.NewDecoder(resp.Body).Decode(&user)

fmt.Printf("Welcome, %s!\\n", user.Name)`,
            },
          ]}
        />
      </section>

      <section style={{ marginBottom: "3rem" }}>
        <h2 className="docs-heading">Available Scopes</h2>
        <p className="docs-text">
          Request only what you need. Users see exactly what you&apos;re asking for.
        </p>
        <div className="docs-table-wrapper">
          <table>
            <thead>
              <tr>
                <th>Scope</th>
                <th>Fields</th>
              </tr>
            </thead>
            <tbody>
              {Object.entries(AVAILABLE_SCOPES).map(([scope, desc]) => (
                <tr key={scope}>
                  <td>
                    <code>{scope}</code>
                  </td>
                  <td style={{ color: "var(--g13)" }}>{desc}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </section>

      <section style={{ marginBottom: "3rem" }}>
        <h2 className="docs-heading">Error Handling</h2>
        <div className="docs-table-wrapper">
          <table>
            <thead>
              <tr>
                <th>Error</th>
                <th>Cause</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>invalid_client</code></td>
                <td style={{ color: "var(--g13)" }}>Unknown client_id or wrong secret</td>
              </tr>
              <tr>
                <td><code>invalid_grant</code></td>
                <td style={{ color: "var(--g13)" }}>Code expired, already used, or PKCE mismatch</td>
              </tr>
              <tr>
                <td><code>invalid_token</code></td>
                <td style={{ color: "var(--g13)" }}>Access token expired or revoked</td>
              </tr>
              <tr>
                <td><code>insufficient_scope</code></td>
                <td style={{ color: "var(--g13)" }}>User didn&apos;t consent to any fields</td>
              </tr>
              <tr>
                <td><code>access_denied</code></td>
                <td style={{ color: "var(--g13)" }}>User clicked &quot;Deny&quot; on consent screen</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <section style={{ marginBottom: "3rem" }}>
        <h2 className="docs-heading">Try It</h2>
        <p className="docs-text">
          Test the full flow interactively without writing code.
        </p>
        <a href="/tester" className="btn btn-primary" style={{ marginTop: "0.5rem" }}>
          Open OAuth Tester →
        </a>
      </section>
    </div>
  );
}
================================================================================

FILE: app/login/action.ts
================================================================================
"use server";

import { redirect } from "next/navigation";
import { db } from "@/lib/db";
import { users } from "@/lib/db/schema";
import { eq } from "drizzle-orm";
import { getSession } from "@/lib/session";
import { loginAndGetProfile } from "@/lib/pesu-auth";
import { loginLimit } from "@/lib/rate-limit";
import { headers } from "next/headers";

interface LoginState {
  error: string | null;
}

export async function loginAction(
  _prev: LoginState,
  formData: FormData
): Promise<LoginState> {
  const username = (formData.get("username") as string)?.trim().toLowerCase();
  const password = formData.get("password") as string;
  const next = formData.get("next") as string | null;

  if (!username || !password) {
    return { error: "Username and password are required." };
  }

  const headerList = await headers();
  const ip =
    headerList.get("x-forwarded-for")?.split(",")[0]?.trim() ?? "unknown";
  const { success } = await loginLimit.limit(ip);
  if (!success) {
    return { error: "Too many login attempts. Try again later." };
  }

  const result = await loginAndGetProfile(username, password);

  if (!result.success || !result.profile) {
    return { error: result.error ?? "Login failed." };
  }

  const prn = (result.profile.prn ?? username).toLowerCase();

  const existing = await db
    .select()
    .from(users)
    .where(eq(users.pesuprn, prn))
    .limit(1);

  let userId: number;

  if (existing.length > 0) {
    const merged = {
      ...((existing[0].profileData as Record<string, unknown>) ?? {}),
      ...result.profile,
    };
    await db
      .update(users)
      .set({ profileData: merged })
      .where(eq(users.id, existing[0].id));
    userId = existing[0].id;
  } else {
    const inserted = await db
      .insert(users)
      .values({ pesuprn: prn, profileData: result.profile })
      .returning({ id: users.id });
    userId = inserted[0].id;
  }

  const session = await getSession();
  session.userId = userId;
  await session.save();

  let redirectTo = "/";
  if (next && next.startsWith("/") && !next.startsWith("//")) {
    redirectTo = next;
  }

  redirect(redirectTo);
}
================================================================================

FILE: app/login/login-form.tsx
================================================================================
"use client";

import { useActionState } from "react";
import { loginAction } from "./action";

export function LoginForm({ next }: { next?: string }) {
  const [state, formAction, pending] = useActionState(loginAction, {
    error: null as string | null,
  });

  return (
    <form action={formAction}>
      {next && <input type="hidden" name="next" value={next} />}

      {state.error && (
        <div className="alert alert-danger">{state.error}</div>
      )}

      <div className="form-group">
        <label className="form-label" htmlFor="username">
          SRN / PRN
        </label>
        <input
          className="form-input"
          type="text"
          id="username"
          name="username"
          placeholder="PES1UG21CS001"
          required
          autoFocus
        />
      </div>

      <div className="form-group">
        <label className="form-label" htmlFor="password">
          Password
        </label>
        <input
          className="form-input"
          type="password"
          id="password"
          name="password"
          required
        />
      </div>

      <button
        type="submit"
        className="btn btn-primary"
        disabled={pending}
        style={{ width: "100%", justifyContent: "center", marginTop: "0.5rem" }}
      >
        {pending ? "Signing in..." : "Sign in"}
      </button>

      <p
        className="text-muted"
        style={{ fontSize: "0.7rem", textAlign: "center", marginTop: "1rem" }}
      >
        Credentials are verified with PESU Academy and not stored.
      </p>
    </form>
  );
}
================================================================================

FILE: app/login/page.tsx
================================================================================
import { redirect } from "next/navigation";
import { getCurrentUser } from "@/lib/auth";
import { LoginForm } from "./login-form";

export default async function LoginPage({
  searchParams,
}: {
  searchParams: Promise<{ next?: string }>;
}) {
  const user = await getCurrentUser();
  if (user) redirect("/");

  const params = await searchParams;

  return (
    <div className="container" style={{ paddingTop: "6rem", maxWidth: "380px" }}>
      <h1 style={{ fontSize: "1.3rem", marginBottom: "0.25rem" }}>Sign in</h1>
      <p className="text-muted" style={{ fontSize: "0.8rem", marginBottom: "1.5rem" }}>
        Use your PESU Academy credentials.
      </p>
      <LoginForm next={params.next} />
    </div>
  );
}
================================================================================

FILE: app/logout/route.ts
================================================================================
import { getSession } from "@/lib/session";
import { redirect } from "next/navigation";

export async function GET() {
  const session = await getSession();
  session.destroy();
  redirect("/");
}
================================================================================

FILE: app/oauth2/authorize/action.ts
================================================================================
"use server";

import { redirect } from "next/navigation";
import { requireAuth } from "@/lib/auth";
import { createAuthorizationCode } from "@/lib/oauth2/grants";
import { SCOPE_FIELDS } from "@/lib/constants";

interface ConsentState {
  error: string | null;
}

export async function consentAction(
  _prev: ConsentState,
  formData: FormData
): Promise<ConsentState> {
  const user = await requireAuth();

  const action = formData.get("action") as string;
  const clientId = formData.get("client_id") as string;
  const redirectUri = formData.get("redirect_uri") as string;
  const scope = formData.get("scope") as string;
  const state = formData.get("state") as string;
  const codeChallenge = formData.get("code_challenge") as string;
  const codeChallengeMethod = formData.get("code_challenge_method") as string;

  if (!clientId || !redirectUri || !scope || !codeChallenge) {
    return { error: "Missing required parameters." };
  }

  if (action === "deny") {
    const url = new URL(redirectUri);
    url.searchParams.set("error", "access_denied");
    url.searchParams.set("error_description", "User denied the request");
    if (state) url.searchParams.set("state", state);
    redirect(url.toString());
  }

  const rawFields = formData.getAll("granted_fields") as string[];
  const requestedScopes = scope.split(" ");
  const grantedFields: Record<string, string[]> = {};

  for (const entry of rawFields) {
    const lastColon = entry.lastIndexOf(":");
    if (lastColon === -1) continue;

    const scopePart = entry.substring(0, lastColon);
    const fieldPart = entry.substring(lastColon + 1);

    if (!requestedScopes.includes(scopePart)) continue;
    if (!SCOPE_FIELDS[scopePart]?.[fieldPart]) continue;

    if (!grantedFields[scopePart]) grantedFields[scopePart] = [];
    grantedFields[scopePart].push(fieldPart);
  }

  const code = await createAuthorizationCode({
    userId: user.id,
    clientId,
    redirectUri,
    scope,
    codeChallenge,
    codeChallengeMethod,
    grantedFields,
  });

  const url = new URL(redirectUri);
  url.searchParams.set("code", code);
  if (state) url.searchParams.set("state", state);
  redirect(url.toString());
}
================================================================================

FILE: app/oauth2/authorize/consent-form.tsx
================================================================================
"use client";

import { useActionState } from "react";
import { consentAction } from "./action";

interface Props {
  clientId: string;
  redirectUri: string;
  scope: string;
  state: string;
  codeChallenge: string;
  codeChallengeMethod: string;
  requestedScopes: string[];
  scopeDescriptions: Record<string, string>;
  scopeFields: Record<string, Record<string, string>>;
  profile: Record<string, unknown>;
}

export function ConsentForm({
  clientId,
  redirectUri,
  scope,
  state,
  codeChallenge,
  codeChallengeMethod,
  requestedScopes,
  scopeDescriptions,
  scopeFields,
  profile,
}: Props) {
  const [formState, formAction, pending] = useActionState(consentAction, {
    error: null as string | null,
  });

  return (
    <form action={formAction}>
      <input type="hidden" name="client_id" value={clientId} />
      <input type="hidden" name="redirect_uri" value={redirectUri} />
      <input type="hidden" name="scope" value={scope} />
      <input type="hidden" name="state" value={state} />
      <input type="hidden" name="code_challenge" value={codeChallenge} />
      <input type="hidden" name="code_challenge_method" value={codeChallengeMethod} />

      {formState.error && (
        <div className="alert alert-danger">{formState.error}</div>
      )}

      <div style={{ marginBottom: "1rem" }}>
        <p style={{ fontSize: "0.75rem", color: "var(--g12)", marginBottom: "0.75rem" }}>
          Select what to share:
        </p>

        {requestedScopes.map((s) => (
          <div
            key={s}
            style={{
              border: "1px solid var(--border)",
              marginBottom: "0.5rem",
              background: "var(--g2)",
            }}
          >
            <div
              style={{
                padding: "0.5rem 0.75rem",
                borderBottom: "1px solid var(--border)",
                background: "var(--g3)",
                fontSize: "0.8rem",
              }}
            >
              <strong>{s}</strong>
              <br />
              <span className="text-muted" style={{ fontSize: "0.7rem" }}>
                {scopeDescriptions[s]}
              </span>
            </div>
            <div style={{ padding: "0.5rem 0.75rem" }}>
              {scopeFields[s] &&
                Object.entries(scopeFields[s]).map(([field, desc]) => {
                  const val = profile[field];
                  return (
                    <div className="checkbox-group" key={`${s}:${field}`}>
                      <input
                        type="checkbox"
                        name="granted_fields"
                        value={`${s}:${field}`}
                        id={`f-${s}-${field}`}
                        defaultChecked
                      />
                      <label
                        htmlFor={`f-${s}-${field}`}
                        style={{ fontSize: "0.8rem" }}
                      >
                        <strong>{field}</strong>
                        <span className="text-muted"> — {desc}</span>
                        {val ? (
                          <span style={{ fontSize: "0.7rem", color: "var(--g13)", display: "block" }}>
                            {field === "photo_base64" ? "Photo available" : `Current: ${String(val)}`}
                          </span>
                        ) : (
                          <span style={{ fontSize: "0.7rem", color: "#a80", display: "block" }}>
                            Not available
                          </span>
                        )}
                      </label>
                    </div>
                  );
                })}
            </div>
          </div>
        ))}
      </div>

      <div style={{ display: "flex", gap: "0.5rem" }}>
        <button
          type="submit"
          name="action"
          value="allow"
          className="btn btn-primary"
          disabled={pending}
          style={{ flex: 1, justifyContent: "center" }}
        >
          {pending ? "..." : "Allow"}
        </button>
        <button
          type="submit"
          name="action"
          value="deny"
          className="btn btn-secondary"
          disabled={pending}
          style={{ flex: 1, justifyContent: "center" }}
        >
          Deny
        </button>
      </div>
    </form>
  );
}
================================================================================

FILE: app/oauth2/authorize/page.tsx
================================================================================
import { redirect } from "next/navigation";
import { getCurrentUser } from "@/lib/auth";
import { getClient } from "@/lib/oauth2/grants";
import { AVAILABLE_SCOPES, SCOPE_FIELDS } from "@/lib/constants";
import { ConsentForm } from "./consent-form";

interface SearchParams {
  response_type?: string;
  client_id?: string;
  redirect_uri?: string;
  scope?: string;
  state?: string;
  code_challenge?: string;
  code_challenge_method?: string;
}

export default async function AuthorizePage({
  searchParams,
}: {
  searchParams: Promise<SearchParams>;
}) {
  const user = await getCurrentUser();
  const params = await searchParams;

  if (!user) {
    const qs = new URLSearchParams(params as Record<string, string>).toString();
    redirect(`/login?next=${encodeURIComponent(`/oauth2/authorize?${qs}`)}`);
  }

  if (params.response_type !== "code") {
    return (
      <div className="container" style={{ paddingTop: "6rem", maxWidth: "500px" }}>
        <div className="alert alert-danger">
          Invalid response_type. Must be &quot;code&quot;.
        </div>
      </div>
    );
  }

  if (!params.client_id || !params.redirect_uri || !params.scope) {
    return (
      <div className="container" style={{ paddingTop: "6rem", maxWidth: "500px" }}>
        <div className="alert alert-danger">
          Missing required parameters: client_id, redirect_uri, scope.
        </div>
      </div>
    );
  }

  if (!params.code_challenge || params.code_challenge_method !== "S256") {
    return (
      <div className="container" style={{ paddingTop: "6rem", maxWidth: "500px" }}>
        <div className="alert alert-danger">
          PKCE required. Provide code_challenge with method S256.
        </div>
      </div>
    );
  }

  const client = await getClient(params.client_id);

  if (!client) {
    return (
      <div className="container" style={{ paddingTop: "6rem", maxWidth: "500px" }}>
        <div className="alert alert-danger">Unknown client_id.</div>
      </div>
    );
  }

  const uris = client.redirectUris as string[];
  if (!uris.includes(params.redirect_uri)) {
    return (
      <div className="container" style={{ paddingTop: "6rem", maxWidth: "500px" }}>
        <div className="alert alert-danger">Redirect URI not registered.</div>
      </div>
    );
  }

  const requestedScopes = params.scope.split(" ").filter((s) => s in AVAILABLE_SCOPES);

  if (requestedScopes.length === 0) {
    return (
      <div className="container" style={{ paddingTop: "6rem", maxWidth: "500px" }}>
        <div className="alert alert-danger">No valid scopes requested.</div>
      </div>
    );
  }

  const profile = (user.profileData ?? {}) as Record<string, unknown>;

  return (
    <div className="container" style={{ paddingTop: "6rem", maxWidth: "500px" }}>
      <h1 style={{ fontSize: "1.2rem", marginBottom: "0.25rem" }}>
        Authorize
      </h1>
      <p className="text-muted" style={{ fontSize: "0.8rem", marginBottom: "1.5rem" }}>
        <strong>{client.clientName}</strong> wants access to your account.
      </p>

      <div
        style={{
          padding: "0.6rem 0.8rem",
          background: "var(--g2)",
          border: "1px solid var(--border)",
          marginBottom: "1rem",
          fontSize: "0.8rem",
        }}
      >
        <span className="text-muted">Signed in as </span>
        <strong>{user.pesuprn}</strong>
        <span style={{ marginLeft: "0.5rem" }}>
          {client.clientSecret === null ? (
            <span className="badge badge-info">Public</span>
          ) : (
            <span className="badge badge-success">Confidential</span>
          )}
        </span>
      </div>

      <ConsentForm
        clientId={params.client_id}
        redirectUri={params.redirect_uri}
        scope={params.scope}
        state={params.state ?? ""}
        codeChallenge={params.code_challenge}
        codeChallengeMethod={params.code_challenge_method}
        requestedScopes={requestedScopes}
        scopeDescriptions={AVAILABLE_SCOPES}
        scopeFields={SCOPE_FIELDS}
        profile={profile}
      />
    </div>
  );
}
================================================================================

FILE: app/tester/page.tsx
================================================================================
import { redirect } from "next/navigation";
import { getCurrentUser } from "@/lib/auth";
import { AVAILABLE_SCOPES } from "@/lib/constants";
import { TesterClient } from "./tester-client";

export default async function TesterPage() {
  const user = await getCurrentUser();
  if (!user) redirect("/login?next=/tester");

  const defaultClientId = process.env.TESTER_CLIENT_ID ?? "";

  return (
    <div className="container" style={{ paddingTop: "6rem", maxWidth: "720px" }}>
      <h1 style={{ fontSize: "1.5rem", marginBottom: "0.5rem" }}>OAuth Tester</h1>
      <p className="text-muted" style={{ fontSize: "0.85rem", marginBottom: "2rem" }}>
        Test the full OAuth flow interactively.
      </p>
      <TesterClient
        defaultClientId={defaultClientId}
        availableScopes={AVAILABLE_SCOPES}
      />
    </div>
  );
}
================================================================================

FILE: app/tester/tester-client.tsx
================================================================================
"use client";

import { useState, useEffect } from "react";

interface Props {
  defaultClientId: string;
  availableScopes: Record<string, string>;
}

export function TesterClient({ defaultClientId, availableScopes }: Props) {
  const [clientId, setClientId] = useState(defaultClientId);
  const [scopes, setScopes] = useState<string[]>(Object.keys(availableScopes));
  const [verifier, setVerifier] = useState("");
  const [challenge, setChallenge] = useState("");
  const [authUrl, setAuthUrl] = useState("");
  const [code, setCode] = useState("");
  const [token, setToken] = useState("");
  const [userData, setUserData] = useState("");
  const [error, setError] = useState("");

  useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    const c = params.get("code");
    if (c) {
      setCode(c);
      window.history.replaceState({}, "", window.location.pathname);
    }
  }, []);

  async function generatePKCE() {
    const v = crypto.randomUUID() + crypto.randomUUID();
    setVerifier(v);
    const hash = await crypto.subtle.digest(
      "SHA-256",
      new TextEncoder().encode(v)
    );
    const c = btoa(String.fromCharCode(...new Uint8Array(hash)))
      .replace(/\+/g, "-")
      .replace(/\//g, "_")
      .replace(/=+$/, "");
    setChallenge(c);
    return { v, c };
  }

  async function startAuth() {
    if (!clientId) {
      setError("Client ID required");
      return;
    }
    setError("");
    const { v, c } = await generatePKCE();
    sessionStorage.setItem("pkce_verifier", v);

    const redirectUri = window.location.origin + window.location.pathname;
    const state = crypto.randomUUID();
    sessionStorage.setItem("oauth_state", state);

    const url = new URL("/oauth2/authorize", window.location.origin);
    url.searchParams.set("response_type", "code");
    url.searchParams.set("client_id", clientId);
    url.searchParams.set("redirect_uri", redirectUri);
    url.searchParams.set("scope", scopes.join(" "));
    url.searchParams.set("state", state);
    url.searchParams.set("code_challenge", c);
    url.searchParams.set("code_challenge_method", "S256");

    setAuthUrl(url.toString());
    window.location.href = url.toString();
  }

  async function exchangeCode() {
    if (!code) {
      setError("No authorization code");
      return;
    }
    setError("");

    const v = sessionStorage.getItem("pkce_verifier") || verifier;
    if (!v) {
      setError("Missing code verifier");
      return;
    }

    const redirectUri = window.location.origin + window.location.pathname;

    const res = await fetch("/api/oauth2/token", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({
        grant_type: "authorization_code",
        code,
        redirect_uri: redirectUri,
        client_id: clientId,
        code_verifier: v,
      }),
    });

    const data = await res.json();
    if (data.error) {
      setError(`${data.error}: ${data.error_description}`);
      return;
    }

    setToken(data.access_token);
    sessionStorage.setItem("access_token", data.access_token);
  }

  async function fetchUser() {
    const t = token || sessionStorage.getItem("access_token");
    if (!t) {
      setError("No access token");
      return;
    }
    setError("");

    const res = await fetch("/api/v1/user", {
      headers: { Authorization: `Bearer ${t}` },
    });

    const data = await res.json();
    setUserData(JSON.stringify(data, null, 2));
  }

  function reset() {
    setVerifier("");
    setChallenge("");
    setAuthUrl("");
    setCode("");
    setToken("");
    setUserData("");
    setError("");
    sessionStorage.removeItem("pkce_verifier");
    sessionStorage.removeItem("oauth_state");
    sessionStorage.removeItem("access_token");
  }

  return (
    <div>
      {error && <div className="alert alert-danger">{error}</div>}

      <section style={{ marginBottom: "2rem" }}>
        <h2 style={{ fontSize: "0.9rem", marginBottom: "0.75rem", color: "var(--g14)" }}>
          1. Configure
        </h2>
        <div className="form-group">
          <label className="form-label">Client ID</label>
          <input
            className="form-input"
            value={clientId}
            onChange={(e) => setClientId(e.target.value)}
            placeholder="Your client ID"
          />
        </div>
        <div className="form-group">
          <label className="form-label">Scopes</label>
          <div style={{ display: "flex", flexWrap: "wrap", gap: "0.5rem" }}>
            {Object.keys(availableScopes).map((s) => (
              <label key={s} style={{ fontSize: "0.8rem", display: "flex", alignItems: "center", gap: "0.25rem" }}>
                <input
                  type="checkbox"
                  checked={scopes.includes(s)}
                  onChange={(e) => {
                    if (e.target.checked) setScopes([...scopes, s]);
                    else setScopes(scopes.filter((x) => x !== s));
                  }}
                />
                {s}
              </label>
            ))}
          </div>
        </div>
        <button className="btn btn-primary" onClick={startAuth}>
          Start Authorization
        </button>
      </section>

      {code && (
        <section style={{ marginBottom: "2rem" }}>
          <h2 style={{ fontSize: "0.9rem", marginBottom: "0.75rem", color: "var(--g14)" }}>
            2. Exchange Code
          </h2>
          <p style={{ fontSize: "0.8rem", color: "var(--g12)", marginBottom: "0.5rem" }}>
            Code received: <code>{code.slice(0, 20)}...</code>
          </p>
          <button className="btn btn-primary" onClick={exchangeCode}>
            Exchange for Token
          </button>
        </section>
      )}

      {token && (
        <section style={{ marginBottom: "2rem" }}>
          <h2 style={{ fontSize: "0.9rem", marginBottom: "0.75rem", color: "var(--g14)" }}>
            3. Fetch User
          </h2>
          <p style={{ fontSize: "0.8rem", color: "var(--g12)", marginBottom: "0.5rem" }}>
            Token: <code>{token.slice(0, 20)}...</code>
          </p>
          <button className="btn btn-primary" onClick={fetchUser}>
            Get User Info
          </button>
        </section>
      )}

      {userData && (
        <section style={{ marginBottom: "2rem" }}>
          <h2 style={{ fontSize: "0.9rem", marginBottom: "0.75rem", color: "var(--g14)" }}>
            User Data
          </h2>
          <pre>{userData}</pre>
        </section>
      )}

      <button className="btn btn-secondary" onClick={reset}>
        Reset
      </button>
    </div>
  );
}
================================================================================

FILE: app/transparency/page.tsx
================================================================================
export default function TransparencyPage() {
  const commitSha = process.env.VERCEL_GIT_COMMIT_SHA;
  const repoOwner = process.env.VERCEL_GIT_REPO_OWNER;
  const repoSlug = process.env.VERCEL_GIT_REPO_SLUG;

  const repoUrl =
    repoOwner && repoSlug
      ? `https://github.com/${repoOwner}/${repoSlug}`
      : "https://github.com/Vision2822/pesu-oauth2";

  const commitUrl = commitSha ? `${repoUrl}/commit/${commitSha}` : null;

  return (
    <div className="container" style={{ paddingTop: "6rem", maxWidth: "600px" }}>
      <h1 style={{ fontSize: "1.5rem", marginBottom: "1.5rem" }}>Transparency</h1>

      <section style={{ marginBottom: "2rem" }}>
        <h2 style={{ fontSize: "1rem", marginBottom: "0.5rem", color: "var(--g16)" }}>
          Open Source
        </h2>
        <p style={{ fontSize: "0.85rem", color: "var(--g13)", lineHeight: 1.6 }}>
          Every line of code is public. You can audit exactly what runs on this
          server.
        </p>
        <p style={{ marginTop: "0.75rem" }}>
          <a
            href={repoUrl}
            target="_blank"
            style={{ fontSize: "0.85rem", color: "var(--g16)", textDecoration: "underline" }}
          >
            View source on GitHub →
          </a>
        </p>
      </section>

      <section style={{ marginBottom: "2rem" }}>
        <h2 style={{ fontSize: "1rem", marginBottom: "0.5rem", color: "var(--g16)" }}>
          No Password Storage
        </h2>
        <p style={{ fontSize: "0.85rem", color: "var(--g13)", lineHeight: 1.6 }}>
          Your PESU password is forwarded to PESU Academy for verification, then
          immediately discarded. We store only your profile data (name, PRN, etc)
          after you consent.
        </p>
      </section>

      <section style={{ marginBottom: "2rem" }}>
        <h2 style={{ fontSize: "1rem", marginBottom: "0.5rem", color: "var(--g16)" }}>
          Granular Consent
        </h2>
        <p style={{ fontSize: "0.85rem", color: "var(--g13)", lineHeight: 1.6 }}>
          Apps request specific data scopes. You see exactly what&apos;s requested
          and can uncheck fields you don&apos;t want to share. You&apos;re always
          in control.
        </p>
      </section>

      {commitUrl && (
        <section style={{ marginBottom: "2rem" }}>
          <h2 style={{ fontSize: "1rem", marginBottom: "0.5rem", color: "var(--g16)" }}>
            Current Deployment
          </h2>
          <p
            style={{
              fontSize: "0.8rem",
              color: "var(--g12)",
              background: "var(--g2)",
              border: "1px solid var(--border)",
              padding: "0.75rem",
              wordBreak: "break-all",
            }}
          >
            <a href={commitUrl} target="_blank" style={{ color: "var(--g14)" }}>
              {commitSha}
            </a>
          </p>
        </section>
      )}
    </div>
  );
}
================================================================================

FILE: components/client-card.tsx
================================================================================
import { deleteClientAction } from "@/app/admin/action";
import { oauth2Clients } from "@/lib/db/schema";

type Client = typeof oauth2Clients.$inferSelect;

export function ClientCard({ client }: { client: Client }) {
  const isPublic = client.clientSecret === null;
  const uris = client.redirectUris as string[];
  const scopes = client.scope.split(" ");

  return (
    <div
      style={{
        border: "1px solid var(--border)",
        background: "var(--g2)",
        padding: "1rem",
      }}
    >
      <div
        style={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "flex-start",
          gap: "1rem",
        }}
      >
        <div style={{ flex: 1, minWidth: 0 }}>
          <div
            style={{
              display: "flex",
              alignItems: "center",
              gap: "0.5rem",
              marginBottom: "0.5rem",
            }}
          >
            <strong style={{ fontSize: "0.9rem" }}>{client.clientName}</strong>
            {isPublic ? (
              <span className="badge badge-info">Public</span>
            ) : (
              <span className="badge badge-success">Confidential</span>
            )}
          </div>

          <div style={{ marginBottom: "0.4rem" }}>
            <span
              style={{
                fontSize: "0.65rem",
                color: "var(--g10)",
                textTransform: "uppercase",
                letterSpacing: "0.05em",
              }}
            >
              Client ID
            </span>
            <br />
            <code
              style={{
                fontSize: "0.75rem",
                wordBreak: "break-all",
              }}
            >
              {client.clientId}
            </code>
          </div>

          <div style={{ marginBottom: "0.4rem" }}>
            <span
              style={{
                fontSize: "0.65rem",
                color: "var(--g10)",
                textTransform: "uppercase",
                letterSpacing: "0.05em",
              }}
            >
              Redirect URIs
            </span>
            <br />
            <div
              style={{ display: "flex", flexWrap: "wrap", gap: "0.25rem", marginTop: "0.15rem" }}
            >
              {uris.map((uri) => (
                <code
                  key={uri}
                  style={{
                    fontSize: "0.7rem",
                    background: "var(--g3)",
                    padding: "0.1rem 0.4rem",
                  }}
                >
                  {uri}
                </code>
              ))}
            </div>
          </div>

          <div>
            <span
              style={{
                fontSize: "0.65rem",
                color: "var(--g10)",
                textTransform: "uppercase",
                letterSpacing: "0.05em",
              }}
            >
              Scopes
            </span>
            <br />
            <div
              style={{ display: "flex", flexWrap: "wrap", gap: "0.25rem", marginTop: "0.15rem" }}
            >
              {scopes.map((s) => (
                <span
                  key={s}
                  style={{
                    fontSize: "0.7rem",
                    background: "var(--g4)",
                    padding: "0.1rem 0.4rem",
                    border: "1px solid var(--border)",
                  }}
                >
                  {s}
                </span>
              ))}
            </div>
          </div>
        </div>

        <form action={deleteClientAction}>
          <input type="hidden" name="id" value={client.id} />
          <button
            type="submit"
            className="btn btn-sm btn-danger"
            onClick={(e) => {
              if (!confirm(`Delete "${client.clientName}"?`)) e.preventDefault();
            }}
          >
            Delete
          </button>
        </form>
      </div>
    </div>
  );
}
================================================================================

FILE: components/footer.tsx
================================================================================
import Link from "next/link";

export function Footer() {
  return (
    <footer
      style={{
        borderTop: "1px solid var(--border)",
        marginTop: "4rem",
        padding: "2rem 0",
      }}
    >
      <div
        className="container"
        style={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          flexWrap: "wrap",
          gap: "1rem",
        }}
      >
        <p style={{ fontSize: "0.7rem", color: "var(--g10)" }}>
          PESU Auth · Not an official PES service
        </p>
        <div style={{ display: "flex", gap: "1.5rem" }}>
          <Link href="/docs" style={{ fontSize: "0.75rem", color: "var(--g12)" }}>
            Docs
          </Link>
          <Link href="/about" style={{ fontSize: "0.75rem", color: "var(--g12)" }}>
            About
          </Link>
          <Link href="/transparency" style={{ fontSize: "0.75rem", color: "var(--g12)" }}>
            Transparency
          </Link>
          <a
            href="https://github.com/Vision2822/pesu-oauth2"
            target="_blank"
            style={{ fontSize: "0.75rem", color: "var(--g12)" }}
          >
            GitHub
          </a>
        </div>
      </div>
    </footer>
  );
}
================================================================================

FILE: components/navbar.tsx
================================================================================
import Link from "next/link";
import { getCurrentUser } from "@/lib/auth";

export async function Navbar() {
  const user = await getCurrentUser();

  return (
    <nav
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        zIndex: 100,
        background: "var(--g1)",
        borderBottom: "1px solid var(--border)",
        padding: "0.75rem 0",
      }}
    >
      <div
        className="container"
        style={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
        }}
      >
        <Link
          href="/"
          style={{ fontWeight: 600, fontSize: "0.9rem", color: "var(--g20)" }}
        >
          PESU Auth
        </Link>

        <div style={{ display: "flex", gap: "1.5rem", alignItems: "center" }}>
          <Link
            href="/docs"
            style={{ fontSize: "0.8rem", color: "var(--g12)" }}
          >
            Docs
          </Link>
          <Link
            href="/tester"
            style={{ fontSize: "0.8rem", color: "var(--g12)" }}
          >
            Tester
          </Link>
          <Link
            href="/about"
            style={{ fontSize: "0.8rem", color: "var(--g12)" }}
          >
            About
          </Link>

          {user ? (
            <div style={{ display: "flex", gap: "0.75rem", alignItems: "center" }}>
              <Link
                href="/admin"
                style={{ fontSize: "0.8rem", color: "var(--g12)" }}
              >
                Admin
              </Link>
              <span
                style={{
                  fontSize: "0.75rem",
                  color: "var(--g10)",
                  padding: "0.2rem 0.5rem",
                  border: "1px solid var(--border)",
                }}
              >
                {user.pesuprn.toUpperCase()}
              </span>
              <Link href="/logout" className="btn btn-sm btn-secondary">
                Logout
              </Link>
            </div>
          ) : (
            <Link href="/login" className="btn btn-sm btn-primary">
              Sign in
            </Link>
          )}
        </div>
      </div>
    </nav>
  );
}
================================================================================

FILE: lib/auth.ts
================================================================================
import { db } from "./db";
import { users } from "./db/schema";
import { eq } from "drizzle-orm";
import { getSession } from "./session";
import { ADMIN_PRNS } from "./constants";

export type User = typeof users.$inferSelect;

export async function getCurrentUser(): Promise<User | null> {
  const session = await getSession();
  if (!session.userId) return null;
  const result = await db
    .select()
    .from(users)
    .where(eq(users.id, session.userId))
    .limit(1);
  return result[0] ?? null;
}

export async function requireAuth(): Promise<User> {
  const user = await getCurrentUser();
  if (!user) throw new Error("UNAUTHORIZED");
  return user;
}

export async function requireAdmin(): Promise<User> {
  const user = await requireAuth();
  if (!ADMIN_PRNS.has(user.pesuprn)) throw new Error("FORBIDDEN");
  return user;
}

export function isAdmin(user: User): boolean {
  return ADMIN_PRNS.has(user.pesuprn);
}
================================================================================

FILE: lib/constants.ts
================================================================================
export const AVAILABLE_SCOPES: Record<string, string> = {
  "profile:basic": "Read your basic identity (Name, PRN, SRN).",
  "profile:academic":
    "Read your academic details (Program, Branch, Semester, Section, Campus).",
  "profile:photo": "Read your profile photo.",
  "profile:contact": "Read your contact information (Email, Phone Number).",
};

export const SCOPE_FIELDS: Record<string, Record<string, string>> = {
  "profile:basic": {
    name: "Full Name",
    prn: "PRN (PES Registration Number)",
    srn: "SRN (Student Registration Number)",
  },
  "profile:academic": {
    program: "Program (e.g., B.Tech, M.Tech)",
    branch: "Branch/Department",
    semester: "Current Semester",
    section: "Section",
    campus: "Campus Name",
    campus_code: "Campus Code",
  },
  "profile:photo": {
    photo_base64: "Profile Photo",
  },
  "profile:contact": {
    email: "Email Address",
    phone: "Phone Number",
  },
};

export const ADMIN_PRNS: Set<string> = new Set(
  (process.env.ADMIN_USERS ?? "")
    .split(",")
    .map((s) => s.trim().toLowerCase())
    .filter(Boolean)
);
================================================================================

FILE: lib/pesu-api.ts
================================================================================
const BASE_URL = "https://www.pesuacademy.com/MAcademy";

const DEFAULT_HEADERS: Record<string, string> = {
  "User-Agent":
    "Mozilla/5.0 (Linux; Android 14) AppleWebKit/537.36 Chrome/143.0 Mobile Safari/537.36",
  "X-Requested-With": "pes.pesu",
  "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
};

export class PESUError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "PESUError";
  }
}

export class AuthError extends PESUError {
  constructor(message: string) {
    super(message);
    this.name = "AuthError";
  }
}

function buildFormData(params: Record<string, string>): string {
  return new URLSearchParams(params).toString();
}

class CookieJar {
  private cookies: Map<string, string> = new Map();

  extract(response: Response) {
    const raw = response.headers.get("set-cookie");
    if (!raw) return;

    const parts = raw.split(/,(?=\s*\w+=)/);
    for (const part of parts) {
      const pair = part.split(";")[0]?.trim();
      if (!pair) continue;
      const eqIndex = pair.indexOf("=");
      if (eqIndex === -1) continue;
      const name = pair.substring(0, eqIndex).trim();
      const value = pair.substring(eqIndex + 1).trim();
      if (name && !["path", "expires", "domain", "max-age", "samesite", "httponly", "secure"].includes(name.toLowerCase())) {
        this.cookies.set(name, value);
      }
    }
  }

  toString(): string {
    const parts: string[] = [];
    this.cookies.forEach((value, name) => {
      parts.push(`${name}=${value}`);
    });
    return parts.join("; ");
  }
}

export async function loginToPESU(
  username: string,
  password: string
): Promise<Record<string, unknown>> {
  const jar = new CookieJar();

  const initResp = await fetch(`${BASE_URL}/mobile/dispatcher`, {
    method: "POST",
    headers: { ...DEFAULT_HEADERS },
    body: buildFormData({
      action: "20",
      mode: "5",
      callMethod: "background",
      minLimit: "0",
      limit: "10",
      randomNum: Math.random().toString(),
    }),
    redirect: "manual",
  });
  jar.extract(initResp);
  await initResp.text();

  const loginResp = await fetch(`${BASE_URL}/j_spring_security_check`, {
    method: "POST",
    headers: {
      ...DEFAULT_HEADERS,
      Cookie: jar.toString(),
    },
    body: buildFormData({
      j_username: username,
      j_password: password,
      j_mobile: "MOBILE",
      j_mobileApp: "YES",
      j_social: "NO",
      j_appId: "1",
      action: "0",
      mode: "0",
      randomNum: Math.random().toString(),
    }),
    redirect: "manual",
  });
  jar.extract(loginResp);

  if (loginResp.status !== 302) {
    throw new AuthError("Invalid credentials");
  }

  const followResp = await fetch(`${BASE_URL}/a/0`, {
    method: "GET",
    headers: {
      ...DEFAULT_HEADERS,
      Cookie: jar.toString(),
    },
    redirect: "manual",
  });
  jar.extract(followResp);
  await followResp.text();

  const successResp = await fetch(`${BASE_URL}/mobile/mobileAppLoginSuccess`, {
    method: "GET",
    headers: {
      ...DEFAULT_HEADERS,
      Cookie: jar.toString(),
    },
    redirect: "manual",
  });
  jar.extract(successResp);

  if (!successResp.ok) {
    throw new PESUError(
      `Login success endpoint returned ${successResp.status}`
    );
  }

  const text = await successResp.text();

  let userData: Record<string, unknown>;
  try {
    userData = JSON.parse(text);
  } catch {
    throw new PESUError(`Failed to parse response: ${text.substring(0, 200)}`);
  }

  if (userData.login !== "SUCCESS") {
    throw new AuthError("Login unsuccessful");
  }

  return userData;
}
================================================================================

FILE: lib/pesu-auth.ts
================================================================================
import { loginToPESU, AuthError, PESUError } from "./pesu-api";

interface ParentInfo {
  name: string | null;
  email: string | null;
  phone: string | null;
  type: "father" | "mother";
  occupation: string | null;
  designation: string | null;
}

export interface PESUProfile {
  name: string | null;
  prn: string | null;
  srn: string | null;
  date_of_birth: string | null;
  email: string | null;
  phone: string | null;
  program: string | null;
  branch: string | null;
  semester: string | null;
  section: string | null;
  section_name: string | null;
  class_name: string | null;
  batch_class_id: unknown;
  class_batch_section_id: unknown;
  user_id: unknown;
  campus_code: number | null;
  campus: string | null;
  photo_base64: string | null;
  parents: ParentInfo[];
}

export interface LoginResult {
  success: boolean;
  profile: PESUProfile | null;
  error: string | null;
}

function parseCampus(loginId: string | null): {
  campus_code: number | null;
  campus: string | null;
} {
  if (!loginId) return { campus_code: null, campus: null };
  const match = loginId.match(/^PES(\d)/);
  if (!match) return { campus_code: null, campus: null };
  const code = parseInt(match[1], 10);
  return { campus_code: code, campus: code === 1 ? "RR" : "EC" };
}

function parsePhoto(rawPhoto: unknown): string | null {
  if (!rawPhoto || typeof rawPhoto !== "string") return null;
  if (rawPhoto.includes("base64,")) {
    return rawPhoto.split("base64,").pop()?.trim() ?? null;
  }
  return rawPhoto;
}

function parseSemesterSection(
  className: unknown
): [string | null, string | null] {
  if (!className || typeof className !== "string") return [null, null];
  const match = className.match(/Sem-(\d+),\s*Section\s+(\S+)/);
  if (match) return [match[1], match[2]];
  return [null, null];
}

function parseBranch(rawBranch: unknown): string | null {
  if (!rawBranch || typeof rawBranch !== "string") return null;
  return rawBranch.startsWith("Branch:")
    ? rawBranch.slice(7).trim()
    : rawBranch;
}

function str(val: unknown): string | null {
  if (val === null || val === undefined) return null;
  return String(val);
}

export async function loginAndGetProfile(
  username: string,
  password: string
): Promise<LoginResult> {
  try {
    const user = await loginToPESU(username, password);
    const [semester, section] = parseSemesterSection(user.className);
    const campusInfo = parseCampus(str(user.loginId));

    const parents: ParentInfo[] = Array.isArray(user.userParentList)
      ? user.userParentList.map((p: Record<string, unknown>) => ({
          name: str(p.name),
          email: str(p.email),
          phone: str(p.mobileNumber),
          type: (p.type === 1 ? "father" : "mother") as "father" | "mother",
          occupation: str(p.occupation),
          designation: str(p.designation),
        }))
      : [];

    const profile: PESUProfile = {
      name: str(user.name),
      prn: str(user.loginId),
      srn: str(user.departmentId),
      date_of_birth: str(user.dateofBirth),
      email: str(user.email),
      phone: str(user.phone),
      program: str(user.program),
      branch: parseBranch(user.branch),
      semester,
      section,
      section_name: str(user.sectionName),
      class_name: str(user.className),
      batch_class_id: user.batchClass ?? null,
      class_batch_section_id: user.classBatchSection ?? null,
      user_id: user.userId ?? null,
      ...campusInfo,
      photo_base64: parsePhoto(user.photo),
      parents,
    };

    return { success: true, profile, error: null };
  } catch (e) {
    if (e instanceof AuthError || e instanceof PESUError) {
      return { success: false, profile: null, error: e.message };
    }
    return { success: false, profile: null, error: "An unexpected error occurred" };
  }
}
================================================================================

FILE: lib/rate-limit.ts
================================================================================
import { Ratelimit } from "@upstash/ratelimit";
import { redis } from "./redis";

export const generalLimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(50, "1 h"),
  prefix: "rl:general",
});

export const loginLimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, "1 m"),
  prefix: "rl:login",
});

export const tokenLimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(30, "1 m"),
  prefix: "rl:token",
});

export const apiLimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(200, "1 d"),
  prefix: "rl:api",
});
================================================================================

FILE: lib/redis.ts
================================================================================
import { Redis } from "@upstash/redis";

export const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});
================================================================================

FILE: lib/session.ts
================================================================================
import { getIronSession, IronSession } from "iron-session";
import { cookies } from "next/headers";

export interface SessionData {
  userId?: number;
  grantedFields?: Record<string, string[]>;
}

const SESSION_OPTIONS = {
  password: process.env.SESSION_SECRET!,
  cookieName: "pesu_oauth_session",
  cookieOptions: {
    secure: process.env.NODE_ENV === "production",
    httpOnly: true,
    sameSite: "lax" as const,
    maxAge: 60 * 60 * 24,
  },
};

export async function getSession(): Promise<IronSession<SessionData>> {
  const cookieStore = await cookies();
  return getIronSession<SessionData>(cookieStore, SESSION_OPTIONS);
}
================================================================================

FILE: lib/db/index.ts
================================================================================
import { neon } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-http";
import * as schema from "./schema";

const sql = neon(process.env.DATABASE_URL!);

export const db = drizzle(sql, { schema });
================================================================================

FILE: lib/db/schema.ts
================================================================================
import {
  pgTable,
  serial,
  varchar,
  text,
  integer,
  jsonb,
  boolean,
  index,
  uniqueIndex,
} from "drizzle-orm/pg-core";

export const users = pgTable(
  "users",
  {
    id: serial("id").primaryKey(),
    pesuprn: varchar("pesuprn", { length: 80 }).notNull(),
    profileData: jsonb("profile_data"),
  },
  (table) => [uniqueIndex("users_pesuprn_idx").on(table.pesuprn)]
);

export const oauth2Clients = pgTable(
  "oauth2_clients",
  {
    id: serial("id").primaryKey(),
    userId: integer("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    clientId: varchar("client_id", { length: 48 }).notNull(),
    clientSecret: varchar("client_secret", { length: 255 }),
    clientName: varchar("client_name", { length: 200 }).notNull(),
    redirectUris: jsonb("redirect_uris").notNull().$type<string[]>(),
    scope: text("scope").notNull(),
    tokenEndpointAuthMethod: varchar("token_endpoint_auth_method", {
      length: 20,
    })
      .notNull()
      .default("none"),
    grantTypes: jsonb("grant_types")
      .notNull()
      .$type<string[]>()
      .default(["authorization_code", "refresh_token"]),
    responseTypes: jsonb("response_types")
      .notNull()
      .$type<string[]>()
      .default(["code"]),
    createdAt: integer("created_at")
      .notNull()
      .$defaultFn(() => Math.floor(Date.now() / 1000)),
  },
  (table) => [uniqueIndex("oauth2_clients_client_id_idx").on(table.clientId)]
);

export const oauth2AuthorizationCodes = pgTable(
  "oauth2_authorization_codes",
  {
    id: serial("id").primaryKey(),
    userId: integer("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    clientId: varchar("client_id", { length: 48 }).notNull(),
    code: varchar("code", { length: 120 }).notNull(),
    redirectUri: text("redirect_uri"),
    scope: text("scope"),
    codeChallenge: text("code_challenge"),
    codeChallengeMethod: varchar("code_challenge_method", { length: 10 }),
    grantedFields: jsonb("granted_fields").$type<
      Record<string, string[]>
    >(),
    expiresAt: integer("expires_at").notNull(),
    used: boolean("used").notNull().default(false),
  },
  (table) => [uniqueIndex("oauth2_auth_codes_code_idx").on(table.code)]
);

export const oauth2Tokens = pgTable(
  "oauth2_tokens",
  {
    id: serial("id").primaryKey(),
    userId: integer("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    clientId: varchar("client_id", { length: 48 }).notNull(),
    tokenType: varchar("token_type", { length: 40 })
      .notNull()
      .default("Bearer"),
    accessToken: varchar("access_token", { length: 255 }).notNull(),
    refreshToken: varchar("refresh_token", { length: 255 }),
    scope: text("scope"),
    grantedFields: jsonb("granted_fields").$type<
      Record<string, string[]>
    >(),
    issuedAt: integer("issued_at")
      .notNull()
      .$defaultFn(() => Math.floor(Date.now() / 1000)),
    expiresIn: integer("expires_in").notNull().default(3600),
    revoked: boolean("revoked").notNull().default(false),
  },
  (table) => [
    uniqueIndex("oauth2_tokens_access_token_idx").on(table.accessToken),
    index("oauth2_tokens_refresh_token_idx").on(table.refreshToken),
  ]
);
================================================================================

FILE: lib/oauth2/grants.ts
================================================================================
import { db } from "@/lib/db";
import {
  oauth2Clients,
  oauth2AuthorizationCodes,
} from "@/lib/db/schema";
import { eq, and } from "drizzle-orm";
import { nanoid } from "nanoid";
import bcrypt from "bcryptjs";
import { verifyCodeChallenge } from "./pkce";
import {
  issueTokenPair,
  validateRefreshToken,
  revokeToken,
} from "./tokens";

const CODE_LENGTH = 48;
const CODE_TTL = 600;

export async function getClient(clientId: string) {
  const result = await db
    .select()
    .from(oauth2Clients)
    .where(eq(oauth2Clients.clientId, clientId))
    .limit(1);
  return result[0] ?? null;
}

export async function createAuthorizationCode(params: {
  userId: number;
  clientId: string;
  redirectUri: string;
  scope: string;
  codeChallenge: string;
  codeChallengeMethod: string;
  grantedFields: Record<string, string[]>;
}) {
  const code = nanoid(CODE_LENGTH);
  const now = Math.floor(Date.now() / 1000);

  await db.insert(oauth2AuthorizationCodes).values({
    userId: params.userId,
    clientId: params.clientId,
    code,
    redirectUri: params.redirectUri,
    scope: params.scope,
    codeChallenge: params.codeChallenge,
    codeChallengeMethod: params.codeChallengeMethod,
    grantedFields: params.grantedFields,
    expiresAt: now + CODE_TTL,
  });

  return code;
}

interface TokenRequest {
  grant_type: string;
  code?: string;
  redirect_uri?: string;
  client_id: string;
  client_secret?: string;
  code_verifier?: string;
  refresh_token?: string;
}

interface TokenResponse {
  access_token: string;
  token_type: string;
  expires_in: number;
  refresh_token: string;
  scope: string;
}

interface TokenError {
  error: string;
  error_description: string;
}

export async function handleTokenRequest(
  params: TokenRequest
): Promise<{ data: TokenResponse; status: 200 } | { data: TokenError; status: 400 | 401 }> {
  const client = await getClient(params.client_id);
  if (!client) {
    return {
      data: { error: "invalid_client", error_description: "Unknown client_id" },
      status: 401,
    };
  }

  if (client.tokenEndpointAuthMethod !== "none") {
    if (!params.client_secret) {
      return {
        data: {
          error: "invalid_client",
          error_description: "Missing client_secret",
        },
        status: 401,
      };
    }
    if (!client.clientSecret) {
      return {
        data: {
          error: "invalid_client",
          error_description: "Client misconfigured",
        },
        status: 401,
      };
    }
    const valid = await bcrypt.compare(params.client_secret, client.clientSecret);
    if (!valid) {
      return {
        data: {
          error: "invalid_client",
          error_description: "Invalid client_secret",
        },
        status: 401,
      };
    }
  }

  if (params.grant_type === "authorization_code") {
    return handleAuthCodeGrant(params, client);
  }

  if (params.grant_type === "refresh_token") {
    return handleRefreshGrant(params, client);
  }

  return {
    data: {
      error: "unsupported_grant_type",
      error_description: "Only authorization_code and refresh_token are supported",
    },
    status: 400,
  };
}

async function handleAuthCodeGrant(
  params: TokenRequest,
  client: typeof oauth2Clients.$inferSelect
): Promise<{ data: TokenResponse; status: 200 } | { data: TokenError; status: 400 }> {
  if (!params.code || !params.redirect_uri || !params.code_verifier) {
    return {
      data: {
        error: "invalid_request",
        error_description: "Missing code, redirect_uri, or code_verifier",
      },
      status: 400,
    };
  }

  const authCodes = await db
    .select()
    .from(oauth2AuthorizationCodes)
    .where(
      and(
        eq(oauth2AuthorizationCodes.code, params.code),
        eq(oauth2AuthorizationCodes.clientId, client.clientId)
      )
    )
    .limit(1);

  const authCode = authCodes[0];

  if (!authCode) {
    return {
      data: { error: "invalid_grant", error_description: "Invalid authorization code" },
      status: 400,
    };
  }

  if (authCode.used) {
    return {
      data: { error: "invalid_grant", error_description: "Code already used" },
      status: 400,
    };
  }

  const now = Math.floor(Date.now() / 1000);
  if (authCode.expiresAt < now) {
    return {
      data: { error: "invalid_grant", error_description: "Code expired" },
      status: 400,
    };
  }

  if (authCode.redirectUri !== params.redirect_uri) {
    return {
      data: { error: "invalid_grant", error_description: "Redirect URI mismatch" },
      status: 400,
    };
  }

  if (!authCode.codeChallenge || !authCode.codeChallengeMethod) {
    return {
      data: { error: "invalid_grant", error_description: "Missing PKCE challenge" },
      status: 400,
    };
  }

  const pkceValid = await verifyCodeChallenge(
    params.code_verifier,
    authCode.codeChallenge,
    authCode.codeChallengeMethod
  );

  if (!pkceValid) {
    return {
      data: { error: "invalid_grant", error_description: "PKCE verification failed" },
      status: 400,
    };
  }

  await db
    .update(oauth2AuthorizationCodes)
    .set({ used: true })
    .where(eq(oauth2AuthorizationCodes.id, authCode.id));

  const tokenData = await issueTokenPair({
    userId: authCode.userId,
    clientId: client.clientId,
    scope: authCode.scope ?? "",
    grantedFields: authCode.grantedFields ?? null,
  });

  return { data: tokenData, status: 200 };
}

async function handleRefreshGrant(
  params: TokenRequest,
  client: typeof oauth2Clients.$inferSelect
): Promise<{ data: TokenResponse; status: 200 } | { data: TokenError; status: 400 }> {
  if (!params.refresh_token) {
    return {
      data: { error: "invalid_request", error_description: "Missing refresh_token" },
      status: 400,
    };
  }

  const oldToken = await validateRefreshToken(params.refresh_token);

  if (!oldToken) {
    return {
      data: { error: "invalid_grant", error_description: "Invalid or expired refresh token" },
      status: 400,
    };
  }

  if (oldToken.clientId !== client.clientId) {
    return {
      data: { error: "invalid_grant", error_description: "Token does not belong to this client" },
      status: 400,
    };
  }

  await revokeToken(oldToken.id);

  const tokenData = await issueTokenPair({
    userId: oldToken.userId,
    clientId: client.clientId,
    scope: oldToken.scope ?? "",
    grantedFields: oldToken.grantedFields ?? null,
  });

  return { data: tokenData, status: 200 };
}
================================================================================

FILE: lib/oauth2/pkce.ts
================================================================================
export async function verifyCodeChallenge(
  verifier: string,
  challenge: string,
  method: string
): Promise<boolean> {
  if (method !== "S256") return false;

  const encoder = new TextEncoder();
  const data = encoder.encode(verifier);
  const digest = await crypto.subtle.digest("SHA-256", data);

  const computed = Buffer.from(digest)
    .toString("base64")
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=+$/, "");

  return computed === challenge;
}
================================================================================

FILE: lib/oauth2/token.ts
================================================================================
import { nanoid } from "nanoid";
import { db } from "@/lib/db";
import { oauth2Tokens } from "@/lib/db/schema";
import { eq, and } from "drizzle-orm";

const ACCESS_TOKEN_LENGTH = 48;
const REFRESH_TOKEN_LENGTH = 48;
const ACCESS_TOKEN_TTL = 3600;

interface TokenPayload {
  userId: number;
  clientId: string;
  scope: string;
  grantedFields: Record<string, string[]> | null;
}

export async function issueTokenPair(payload: TokenPayload) {
  const accessToken = nanoid(ACCESS_TOKEN_LENGTH);
  const refreshToken = nanoid(REFRESH_TOKEN_LENGTH);
  const now = Math.floor(Date.now() / 1000);

  await db.insert(oauth2Tokens).values({
    userId: payload.userId,
    clientId: payload.clientId,
    accessToken,
    refreshToken,
    scope: payload.scope,
    grantedFields: payload.grantedFields,
    issuedAt: now,
    expiresIn: ACCESS_TOKEN_TTL,
  });

  return {
    access_token: accessToken,
    token_type: "Bearer",
    expires_in: ACCESS_TOKEN_TTL,
    refresh_token: refreshToken,
    scope: payload.scope,
  };
}

export async function validateAccessToken(token: string) {
  const result = await db
    .select()
    .from(oauth2Tokens)
    .where(
      and(eq(oauth2Tokens.accessToken, token), eq(oauth2Tokens.revoked, false))
    )
    .limit(1);

  if (result.length === 0) return null;

  const row = result[0];
  const now = Math.floor(Date.now() / 1000);

  if (row.issuedAt + row.expiresIn < now) return null;

  return row;
}

export async function validateRefreshToken(token: string) {
  const result = await db
    .select()
    .from(oauth2Tokens)
    .where(
      and(
        eq(oauth2Tokens.refreshToken, token),
        eq(oauth2Tokens.revoked, false)
      )
    )
    .limit(1);

  if (result.length === 0) return null;

  const row = result[0];
  const now = Math.floor(Date.now() / 1000);
  const refreshTTL = row.expiresIn * 2;

  if (row.issuedAt + refreshTTL < now) return null;

  return row;
}

export async function revokeToken(id: number) {
  await db
    .update(oauth2Tokens)
    .set({ revoked: true })
    .where(eq(oauth2Tokens.id, id));
}
================================================================================

